# 번역
---
# 1 클린코드
코드 정리
리팩터링의 주된 목적은 기술 부채를 없애는 것입니다. 리팩터링은 복잡한 코드를 깔끔한 코드와 단순한 디자인으로 바꿔줍니다.

멋지네요! 그런데 클린 코드란 무엇일까요? 다음은 몇 가지 특징입니다:

 깔끔한 코드는 다른 프로그래머에게도 분명합니다.
그리고 저는 매우 정교한 알고리즘에 대해 말하는 것이 아닙니다. 잘못된 변수 명명, 부풀려진 클래스 및 메서드, 매직넘버 등 모든 것이 코드를 엉성하고 이해하기 어렵게 만듭니다.

 깔끔한 코드는 중복을 포함하지 않습니다.
중복된 코드를 변경해야 할 때마다 모든 인스턴스에 동일한 변경 사항을 적용해야 한다는 점을 기억해야 합니다. 이렇게 하면 인지 부하가 증가하고 진행 속도가 느려집니다.

 깔끔한 코드에는 최소한의 클래스 및 기타 움직이는 부분이 포함됩니다.
코드가 적을수록 머릿속에 기억해야 할 내용이 줄어듭니다. 코드가 적으면 유지 관리도 줄어듭니다. 코드가 적으면 버그도 줄어듭니다. 코드는 책임이므로 짧고 단순하게 유지하세요.

 깔끔한 코드는 모든 테스트를 통과합니다.
테스트의 95%만 통과하면 코드가 더럽다는 것을 알 수 있습니다. 테스트 커버리지가 0%라면 문제가 있다는 것을 알 수 있습니다.

 깔끔한 코드는 유지 관리가 더 쉽고 저렴합니다!

---
# 2 
---
기술 부채
누구나 처음부터 훌륭한 코드를 작성하기 위해 최선을 다합니다. 프로젝트에 해를 끼칠 목적으로 의도적으로 불결한 코드를 작성하는 프로그래머는 아마 없을 것입니다. 하지만 언제부터 깨끗한 코드가 불결한 코드가 될까요?

부정한 코드와 관련하여 "기술적 부채"라는 은유는 원래 워드 커닝햄이 제안한 것입니다.

은행에서 대출을 받으면 구매를 더 빨리 할 수 있습니다. 원금만 갚는 것이 아니라 대출에 대한 추가 이자도 갚아야 하므로 프로세스를 신속하게 처리하기 위해 추가 비용을 지불하게 됩니다. 말할 필요도 없이, 이자가 너무 많이 쌓여 이자 금액이 총 수입을 초과하여 전액 상환이 불가능해질 수도 있습니다.

코드에서도 같은 일이 발생할 수 있습니다. 새로운 기능에 대한 테스트를 작성하지 않고 일시적으로 속도를 높일 수는 있지만, 결국 테스트를 작성하여 빚을 갚을 때까지 매일 조금씩 진행 속도가 느려질 것입니다.

기술 부채의 원인
 비즈니스 압박
때로는 비즈니스 상황으로 인해 기능이 완전히 완성되기 전에 출시해야 할 수도 있습니다. 이 경우 프로젝트의 미완성 부분을 숨기기 위해 코드에 패치와 클루지가 나타납니다.

 기술 부채의 결과에 대한 이해 부족
때때로 고용주는 기술 부채가 누적됨에 따라 개발 속도가 느려진다는 점에서 기술 부채에 '이자'가 있다는 사실을 이해하지 못할 수 있습니다. 경영진이 리팩토링의 가치를 인정하지 않기 때문에 팀이 리팩토링에 시간을 할애하는 것이 너무 어려워질 수 있습니다.

 구성 요소의 엄격한 일관성을 유지하지 못하는 경우
프로젝트가 개별 모듈의 산물이라기보다는 하나의 모놀리스처럼 보이는 경우입니다. 이 경우 프로젝트의 한 부분을 변경하면 다른 부분에 영향을 미칩니다. 개별 구성원의 작업을 분리하기 어렵기 때문에 팀 개발이 더 어려워집니다.

 테스트 부족
즉각적인 피드백이 부족하면 신속하지만 위험한 미봉책이나 편법을 사용하게 됩니다. 최악의 경우, 이러한 변경 사항은 사전 테스트 없이 바로 프로덕션에 구현 및 배포됩니다. 그 결과는 치명적일 수 있습니다. 예를 들어, 아무 문제 없어 보이는 핫픽스가 수천 명의 고객에게 이상한 테스트 이메일을 보내거나 더 심각한 경우 전체 데이터베이스를 플러시하거나 손상시킬 수 있습니다.

 문서화 부족
문서가 부족하면 프로젝트에 새로운 인력이 유입되는 속도가 느려지고 핵심 인력이 프로젝트를 떠날 경우 개발이 중단될 수 있습니다.

 팀원 간의 상호 작용 부족
지식창고가 회사 전체에 배포되지 않으면 사람들은 프로젝트에 대한 프로세스 및 정보를 구식으로 이해한 채로 작업하게 됩니다. 이러한 상황은 주니어 개발자가 멘토로부터 잘못된 교육을 받으면 더욱 악화될 수 있습니다.

 여러 브랜치에서 장기적으로 동시에 개발하는 경우
이로 인해 기술 부채가 누적될 수 있으며, 이는 변경 사항이 병합될 때 증가합니다. 개별적으로 변경된 사항이 많을수록 총 기술 부채는 더 커집니다.

 지연된 리팩토링
프로젝트의 요구사항은 지속적으로 변화하고 있으며, 어느 시점에서 코드의 일부가 더 이상 사용되지 않거나 번거로워져 새로운 요구사항을 충족하기 위해 다시 설계해야 한다는 것이 분명해질 수 있습니다.

반면에 프로젝트의 프로그래머는 더 이상 사용되지 않는 부분과 함께 작동하는 새로운 코드를 매일 작성하고 있습니다. 따라서 리팩터링이 지연될수록 향후 더 많은 종속 코드를 재작업해야 합니다.

 규정 준수 모니터링 부족
프로젝트에 참여하는 모든 사람이 자신이 적합하다고 생각하는 대로 코드를 작성할 때(즉, 마지막 프로젝트에서 작성한 것과 동일한 방식으로) 발생합니다.

 무능력
개발자가 제대로 된 코드를 작성하는 방법을 모르는 경우입니다.

---

# 3
---
리팩터링해야 하는 시기

3의 법칙
처음으로 무언가를 할 때는 그냥 해치우세요.

비슷한 작업을 두 번째로 할 때는 반복해야 한다는 사실에 움찔하지만 어쨌든 같은 작업을 수행하세요.

세 번째로 무언가를 할 때는 리팩터링을 시작하세요.


기능을 추가할 때
리팩터링은 다른 사람의 코드를 이해하는 데 도움이 됩니다. 다른 사람의 더러운 코드를 다루어야 한다면 먼저 리팩터링을 시도하세요. 깔끔한 코드가 훨씬 이해하기 쉽습니다. 자신뿐만 아니라 이후에 코드를 사용하는 사람들을 위해서도 코드를 개선할 수 있습니다.

리팩터링을 하면 새로운 기능을 더 쉽게 추가할 수 있습니다. 깔끔한 코드에서 변경하는 것이 훨씬 쉽습니다.


버그를 수정할 때
코드의 버그는 실생활의 버그와 마찬가지로 코드의 가장 어둡고 더러운 곳에 존재합니다. 코드를 정리하면 오류는 거의 스스로 발견됩니다.

관리자는 사전 리팩터링을 통해 나중에 특별한 리팩터링 작업을 할 필요가 없으므로 이를 높이 평가합니다. 행복한 상사가 행복한 프로그래머를 만듭니다!


코드 리뷰 중
코드 리뷰는 코드가 공개되기 전에 코드를 정리할 수 있는 마지막 기회일 수 있습니다.

이러한 검토는 작성자와 함께 수행하는 것이 가장 좋습니다. 이렇게 하면 간단한 문제는 빠르게 수정하고 더 어려운 문제를 수정하는 데 걸리는 시간을 측정할 수 있습니다.

---

# 4
---
리팩터링하는 방법
리팩터링은 일련의 작은 변경으로 이루어져야 하며, 각 변경은 기존 코드를 약간 개선하는 동시에 프로그램이 계속 작동하도록 유지해야 합니다.

 올바른 리팩터링 체크리스트
 코드가 더 깔끔해져야 합니다.
리팩터링 후에도 코드가 여전히 깨끗하지 않다면... 죄송하지만 방금 한 시간을 낭비한 것입니다. 왜 이런 일이 발생했는지 알아보세요.

작은 변경 사항으로 리팩터링하는 것에서 벗어나 여러 개의 리팩터링을 하나의 큰 변경 사항으로 혼합할 때 자주 발생합니다. 특히 시간 제한이 있는 경우 정신을 잃기 쉽습니다.

하지만 매우 엉성한 코드로 작업할 때도 이런 일이 발생할 수 있습니다. 무엇을 개선하든 코드 전체는 여전히 엉망입니다.

이 경우 코드의 일부를 완전히 다시 작성하는 것에 대해 생각해 볼 가치가 있습니다. 하지만 그 전에 테스트를 작성하고 충분한 시간을 할애해야 합니다. 그렇지 않으면 첫 번째 단락에서 이야기한 것과 같은 결과를 얻게 될 것입니다.

 리팩토링 중에 새로운 기능을 만들어서는 안 됩니다.
리팩터링과 새로운 기능의 직접 개발을 혼용하지 마세요. 최소한 개별 커밋의 범위 내에서 이러한 프로세스를 분리하세요.

 리팩토링 후에는 모든 기존 테스트를 통과해야 합니다.
리팩토링 후 테스트가 중단될 수 있는 경우는 두 가지가 있습니다:

리팩토링 중에 오류가 발생한 경우. 이 경우는 간단합니다. 오류를 수정하면 됩니다.

테스트가 너무 낮은 수준인 경우. 예를 들어 클래스의 비공개 메서드를 테스트하고 있었습니다.

이 경우 테스트에 책임이 있습니다. 테스트 자체를 리팩터링하거나 완전히 새로운 상위 수준의 테스트를 작성할 수 있습니다. 이러한 상황을 피하는 가장 좋은 방법은 BDD 스타일 테스트를 작성하는 것입니다.

---
